<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    第一章 什么是JavaScript? |
    
    Hexo</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-YDK-JS-2nd-01" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      第一章 什么是JavaScript?
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/06/02/YDK-JS-2nd-01/" class="article-date">
  <time datetime="2020-06-02T11:43:51.000Z" itemprop="datePublished">2020-06-02</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ydk-js-2nd/">You Don't Know JS系列</a>
  </div>

                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>跟很多开发者一样，我们都不能完完全全的理解JS。也并不曾主动去了解。那么就是现在，让我们一起去学习JS更多的内容。</p>
<p>在You Don’t Know JS Yet (YDKJSY)系列文章的第一章中，我们需要花些时间为未来的学习巩固下基础。我们首先需要涵盖很多背景知识及细节，弄清楚关于这门语言（是or不是）的偏见。</p>
<p>这对于深刻理解JS是如何组织、维护的本质与过程是有帮助的，所有的JS开发者都应该理解，如果你想深入了解JS，这里将是学习JS旅程的第一步。</p>
<a id="more"></a>
<h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>我之所以强调旅程这个词是因为，学习JS是没有终点的，那么本书将是一个帮助你学习JS的一个方向，不论你花费多少时间学习这门语言，你都将会或多或少的学习和理解一些知识。所以不要指望这本书能让你快速成手。相反的，耐心和毅力是你学习旅程上最好的开始。</p>
<p>在本章节中，你可以了解到在本书（YDKJS）剩余部分关于深入挖掘和学习JS知识导图。</p>
<p>特别是第四章，我们将介绍JS语言中主要的三部分内容：作用域/闭包、原型/对象、类型/强类型。JS是一门广泛、复杂的语言，有许多特性和功能。但是这些都是建立在以上三个部分。<br>本书虽然标题取名为“开始”，但它并不是一个入门书籍。这本书主要是让你开始了解JS更深层次的知识；开始阅读本书前至少保证你对JS已有几个月的经验。</p>
<p>即使你已经学习过一段时间的JS，你也不能忽略这本书，希望你能在这上面花费一定的时间。一个好的开始往往取决于你坚实的第一步。</p>
<h3 id="JavaScript名字由来"><a href="#JavaScript名字由来" class="headerlink" title="JavaScript名字由来"></a>JavaScript名字由来</h3><p>JavaScript这个名字可能会给很多人带来误解。跟Java有关？又或是Java中的一个Script（脚本）？还是仅仅是一个脚本而不是编程语言。</p>
<p>事实上，Javascript这个名字会捎带些营销策略在里面，当Brendan Eich刚开始构造这门语言时，起名叫做Mocha。后来在Netscape內部它被叫做LiveScript，但是最后公开的名字却是Javascript，“Javascript”赢得了最后的竞选。</p>
<p>为什么？因为这门语言最初是为了吸引Java开发者，并且对于“脚本”这个词往往带给人们的感觉时轻量。这些轻量的脚本将首次嵌入到浏览器的页面中。</p>
<p>换句话说，Javascript的策略是试图利用更具盛名的Java来定位这门语言，就此而言，它也可以简单的称作“WebJava”。在Javascript和Java中存在一定的相似之处，这些相似点并不取决于它们共同的发展，而是针对那些假定期望C（某种程度是C++）语法的开发者的两种语言。例如，我们用{}来分别代表开始代码块和结束代码块，就像C/C++ 和 Java。我们也可以使用 ; 来强调结束语句。</p>
<p>在某些方面上，法律。 Oracle (via Sun)拥有“Java”的商标权，而且通过Netscape公司拥有“JavaScript”商标权，只不过从未执行该商标。</p>
<p>由于这些原因，一些人建议我们将JS替代Javascript。如果针对这门语言没有一个官方的名字，这将是一个非常合适的简写。那么所有书籍所提到的JS其实都是指这门语言。</p>
<p>经过TC39（ECMA的39号技术委员会Technical Committee 39）制定和审核，由ECMA组织发布标准文件，规定了浏览器脚本语言的标准，并将其称ECMAScript。也意味着这门语言于Oracle的品牌关系也渐渐疏离。的确，自2016起，语言的版本修正都是以年份作为后缀；都是以ECMAScript 2019或简写ES2019。</p>
<p>换句话说，目前在浏览器或者node.js中运行的Javascript/JS，是ES2019标准的实现。</p>
<blockquote>
<p>不要使用诸如“JS6”或“ES8”来指代这门语言。这只会导致混乱。我们应该常用“ES20xx”或只是“JS”来指代。</p>
</blockquote>
<p>不论你称它JavaScript, JS, ECMAScript, 或者 ES2019，你都要明确，它跟Java没关系！</p>
<blockquote>
<p>“Java is to JavaScript as ham is to hamster.” –Jeremy Keith, 2009</p>
</blockquote>
<h3 id="语言规范"><a href="#语言规范" class="headerlink" title="语言规范"></a>语言规范</h3><p>上文中有提及TC39，管理JS的技术委员会。他们主要负责制定和审核这个语言标准。该委员会定期开会表决同意更改，然后提交给ECMA标准组织。</p>
<p>JS的语法及行为规范都定义在ES规格书中。</p>
<p>ES2019恰好是JS自1995年诞生以来第10次修订，所以在官方的URL中你会发现“10.0”:<br><a href="https://www.ecma-international.org/ecma-262/10.0/" target="_blank" rel="noopener">https://www.ecma-international.org/ecma-262/10.0/</a></p>
<p>TC39成员由50~100位来自业内的大公司派出的工程师组成，比如浏览器厂商（火狐、谷歌、苹果）、设备制造商（三星等等）。所有的成员都是以志愿者身份加入。即使如此他们也会从委员会中得到一定的酬劳。</p>
<p>TC39每隔一个月将会召开为期3天左右的会议，回顾上次参会成员的工作、讨论问题和对建议书进行表决。会议地点一般都在与会成员的公司内部。</p>
<p>所有TC39提议都要经过五个阶段，当然对于我们程序员来讲，就一个阶段！关于这5个阶段，可以参考这个连接<a href="https://tc39.es/process-document/" target="_blank" rel="noopener">https://tc39.es/process-document/</a></p>
<p>第一个阶段大致的意思是，某人有了一个好的idea或者plans想加到规范中去。也就是一些开发者在社交媒体或博客文章中提到一些好的想法。然而光有想法是不够的，你必须得到至少一个TC39成员的支持，才算是进入到第一个阶段。</p>
<p>如果一个提议已经经过这5个阶段，那么它将加在下一个版本修订中。而这5个阶段往往需要经过几个月甚至一年的时间。</p>
<p>所有的提议、讨论、会议记录都是公开的，你可以在<a href="https://github.com/tc39/proposals" target="_blank" rel="noopener">https://github.com/tc39/proposals</a>找到。</p>
<p>在整个提议过程中，任何人不管是不是TC39成员，都可以参与公开的讨论和建议。然而只有TC39成员拥有在会议中投票的权力，所以，实际是TC39代表广大开发者门决定JS的发展方向。</p>
<p>相反的对于一些非官方建立、虚拟出的一些规范，不必理会。JS标准只有一个。就是由官方TC39和ECMA组织维护管理。</p>
<p>早在20年代初，由微软公司模仿JS开发了一种相近的语言叫做“JScript”，似乎是合法的实现另一个版本的JS，但随着时间的推移，这个称法对于现在的JS来说是不正确的。</p>
<p>所有的主流浏览器及设备制造商都保证了JS的实现于这一规范。当然运行环境（引擎）的实现并不统一。但是都应该基于V8（Chorme的引擎）或者SpiderMonkey （Mozilla的引擎）。</p>
<p>也就是我们学习的JS，在任何支持JS运行的地方都是通用的。</p>
<h3 id="JS在Web中的规则"><a href="#JS在Web中的规则" class="headerlink" title="JS在Web中的规则"></a>JS在Web中的规则</h3><p>随着JS运行环境的不断扩大（从浏览器到服务端（Node.js），到人工智能、到…），其中一个环境就是Web，那么JS是如何在web浏览器中运行的，就成了在所有实例应用中，唯一切合实际的问题。</p>
<p>在大多情况下，规范中定义的JS和运行在基于浏览器的Javascript引擎中的JS是一样的，但不能保证存在一定的差异性，这是我们要考虑的。</p>
<p>有时JS规范会决定一些新的行为规范，然而，它并不能保证这些新规范能在JS引擎中正常工作。JS引擎已经对JS规范依赖有20年以上的时间，并依赖于Web内容。所以，JS引擎会拒绝一些破坏Web内容的提议。</p>
<p>在这种情况下，TC39通常通过回溯选择简单符合规范的提议，例如，TC39想要在数组中加入<code> contains(..) </code>方法，但是他们发现这个名字与老版本中的一些JS框架存在冲突，所以他们就将名字修改位<code> includes(..) </code>。类似这种充满戏剧性的命名冲突还有<code> flat(..) </code>，它最开始的名字叫做<code> flatten(..) </code>，这种情况在JS社区中被称作“冒牌？？”。</p>
<p>但是，TC39偶尔会通过某些提议，虽然对于JS引擎可能永远不会去做这个规范。</p>
<p>解决方案，在附录B中提到，给Web浏览器提供可拓展的ECMAScript特性。附录详细描述了任何已知在官方JS规范中不适合实际Web环境的情况，换句话说这个附录仅仅给web JS提供了一个免责条款，而其他环境下的JS需严格按着规范执行。</p>
<p>附录B中的1、2部分主要介绍了JS在老版本浏览器中的语法和APIs（或者已经废弃的），但TC39并不打算将其纳入到JS规范中去，例如0-前缀的八进制表示法，全局对象属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/escape" target="_blank" rel="noopener">escape()</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/unescape" target="_blank" rel="noopener">unescape()</a>，string原型方法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/anchor" target="_blank" rel="noopener">anchor()</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/blink" target="_blank" rel="noopener">blink()</a>，RegExp 中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/compile" target="_blank" rel="noopener">compile()</a>等等。</p>
<p>第3部分主要包含一些因运行不同环境而产生的冲突（Web和非Web环境），除了因行为不同而产生不同结果的地方。在严格模式下大多数包含这种情况的错误，都会及时的以列表的形式展现出来。</p>
<p>附录B中的一些问题并不是经常遇到，但是从长远角度来讲这是一个很好的方案来避免这些问题。所以我们尽量遵循JS规范，并且不要针对单一的JS运行环境而做一些行为。</p>
<h3 id="Web不全是JS"><a href="#Web不全是JS" class="headerlink" title="Web不全是JS"></a>Web不全是JS</h3><p>下面这行代码是JS脚本吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&quot;Hello, JS!&quot;);</span><br></pre></td></tr></table></figure>

<p>这取决于个人的理解，<code> alert() </code>方法并不在JS规范中，但是它存在于运行 JS 的 所有 Web 环境中，然而，你也不会在附录B中找到它的说明。</p>
<p>各式各样的JS运行环境（浏览器，Node.js等）会将Api放在全局作用域中，提供一些特殊的能力，就像浏览器中存在alert弹窗一样。</p>
<p>实际上，有大部分Apis只是看起来像JS，像 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">fetch()</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition" target="_blank" rel="noopener">getCurrentPosition()</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia" target="_blank" rel="noopener">getUserMedia()</a>实际上都是 Web’s Api。在Node.js中同样在模块中提供数以百计的Api，比如 fs.write()。</p>
<p>另 外还有<code> console.log() </code>（或者其他console.*方法），都不是JS规范的内容，但是因为他们普遍的应用于运行JS的环境中。所以粗略的认为与JS是一致的。</p>
<p>所以<code>alert(..)</code>和<code>console.log(..)</code>，都不属于JS规范内容，只不过看上去像。这些方法遵循JS语法规范。它们的行为由JS引擎控制，而且必须遵循JS规范才能在JS运行背景下工作。</p>
<p>人们总是抱怨在大部分跨浏览器运行JS时所出现的行为结果不一致，实际上这些问题由不同的运行环境导致，而并非JS本身的问题。</p>
<p>所以，<code>alert(..)</code>在JS中被调用，但是<code>alert</code>真的只是JS的一个 guest ，并不是JS规范里的内容。</p>
<h3 id="It’s-Not-Always-JS"><a href="#It’s-Not-Always-JS" class="headerlink" title="It’s Not Always JS"></a>It’s Not Always JS</h3><p>在浏览器的开发工具(或节点)中使用控制台/REPL(读取-求值-打印-循环)乍一看就像是一个非常简单的JS环境。但事实并非如此。</p>
<p>开发人员工具……对于开发人员工具。它们的主要目的是让开发人员的生活更轻松。他们优先考虑DX(开发人员体验)。准确、纯粹地反映严格规范JS行为的所有细微差别不是这些工具的目标。因此，如果您将控制台视为纯JS环境，那么有许多奇怪之处可能会成为“陷阱”。</p>
<p>顺便说一下，这种便利是件好事!我很高兴开发工具让开发人员的生活更轻松!我很高兴我们有很好的用户体验魅力，比如变量/属性的自动完成，等等。我只是指出，我们不能也不应该期望这些工具总是严格遵守JS程序的处理方式，因为这不是这些工具的目的。</p>
<p>由于这些工具的行为因浏览器的不同而不同，而且它们的变化(有时相当频繁)，因此我不打算在本文中“硬编码”任何具体细节，从而确保本书的文本很快就过时了。</p>
<p>但我只是暗示了一些例子的怪癖，在不同的JS控制台环境的不同点，以加强我的观点，不要假设本地JS行为，而使用他们:</p>
<ul>
<li><p>无论在控制台的顶级“全局作用域”中的var或函数声明实际上都创建了一个真实的全局变量(以及镜像窗口属性，反之亦然!)</p>
</li>
<li><p>在顶级“全局作用域”中声明多个let和const会发生什么?</p>
</li>
<li><p>“是否使用严格的”;在一个行条目上(按 enter 之后)，使严格模式为其余的控制台会话，就像它在.js文件的第一行，以及你是否可以使用“使用严格”;超出“第一行”，仍然为该会话打开严格模式。</p>
</li>
<li><p>对于函数调用，非严格模式的默认绑定如何工作，以及使用的“全局对象”是否包含预期的全局变量。</p>
</li>
<li><p>(参见第2卷，范围和闭包)如何跨多行条目工作。</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>开发人员控制台不会假装成一个JS编译器，它会以JS引擎处理. JS文件的完全相同的方式来处理您输入的代码。它试图让您轻松地快速输入几行代码并立即看到结果。这是完全不同的用例，因此，期望一种工具能够平等地处理两者是不合理的。</p>
<p>不要相信你在developer console中看到的行为代表了完全准确的JS语义;为此，请阅读说明书。相反，可以将控制台看作是“jsp友好”的环境。这本身就很有用。</p>
<h3 id="Many-Faces"><a href="#Many-Faces" class="headerlink" title="Many Faces"></a>Many Faces</h3><p>在编程语言上下文中，术语“范例”指的是构建代码的一种广泛的（几乎是通用的）思维方式和方法。在一个范例中，有无数区分程序的样式和形式的变化，包括无数的lib。</p>
<p>但是，无论一个程序的风格是怎样的，在第一眼看到任何程序时，围绕范例的大划分总是显而易见的。</p>
<p>典型的范例级代码属于程序类别，像OO（面向对象程序设计）、FP（函数式程序设计）：</p>
<ul>
<li><p>程序风格通过一组预先确定的操作（通常在成为过程的相关单元中收集）以自顶向下、线性的方式组织代码。</p>
</li>
<li><p>OO风格 通过将逻辑与数据一起收集到称为类的单元中组织代码。</p>
</li>
<li><p>FP风格将代码组织成函数（纯计算而不是过程），并将这些函数的调整作为值。</p>
</li>
</ul>
<p>范式既不是对的也不是错的。它们是指导和塑造程序员如何处理的解决方案、如何狗仔和维护代码的方向。</p>
<p>有些语言严重倾向于一种范式——C是面向过程，Java/C++几乎完全面向类的，而Haskell则完全面向FP。</p>
<p>但是许多语言也支持来自不同范例的代码模式，甚至混合和匹配来自不同范例。所谓的“多范式语言”提供了极大的灵活性。在某些情况下，一个程序甚至可以同时拥有这些范例的两个或多个表达式。</p>
<p>Javascript绝对是一种多范式语言。您可以编写过程性的、面向类的或FP风格的代码，并且您可以逐行做出这些决定，而不是被迫做出要么全有要么全无的选择。</p>
<h3 id="Backwards-amp-Forwards"><a href="#Backwards-amp-Forwards" class="headerlink" title="Backwards &amp; Forwards"></a>Backwards &amp; Forwards</h3><p>Javascript的最基本原则之一是保持backwards compatibility（向后兼容性）。许多人对这个术语的含义感到困惑，经常将他与一个相关但不同的术语混淆：（forwards compatibility）向前兼容性。</p>
<p>让我们仔细研究下。</p>
<p>向后兼容性意味着一旦某些东西被接受为有效的JS，将来就不会有导致代码成为无效JS的语言改变。1995年的编写的代码———无论多么原始、限制，今天还可以工作，正如TC39成员经常宣称的那样，“我们不会破坏网络！”</p>
<p>这样也就意味着，JS开发者可以满怀信心的编写代码，他们的代码不会因为浏览器更新而不可预测的停止工作。这也使得为一个项目选择JS，在未来几年是一个更加明智和安全的投资。</p>
<p>这种“保证”可不是一件小事。在该语言近25年的历史中，保持向后兼容性带来了巨大的负担和一系列独特的挑战。在计算这种向后兼容性方面，很难找到许多其他例子。</p>
<p>坚持这一原则的代价不应被随意忽略。它必然会为包括改变或拓展语言创造一个非常高的门槛；任何决定都会变成永久性的，包括错误在内。一旦它在JS中，它都不能被删除，因为它可能会破坏程序，即使我们真的很想删除它。</p>
<p>这条规则也有一些小的例外。JS有一些向后不兼容的更改，但是TC39在这样做时非常谨慎。他们研究现有代码的web浏览器（通过数据采集）来估计这些破损的影响，和浏览器最终决定，投票决定是否他们愿意把热量从用户非常小规模的破损给人带来的修复或改善某些方面的语言更多的网站（和用户）。</p>
<p>这些类型的变化是罕见的，而且几乎总是在较少的场景中使用，不太可能在许多网站上被明显破坏。</p>
<p>比较向后与向前兼容性。向前兼容意味着，如果程序在旧的JS引擎中运行，那么程序中添加新的语言不会导致程序中断。然而JS并不是向前兼容，尽管许多人希望如此，甚至错误的认为它就是向前兼容。</p>
<p>相比之下，HTML和CSS是向前兼容的，但是不向后兼容，如果你找到一些在1995年编写的HTML或CSS，它完全有可能在运行时出错。但是如果在2010年的浏览器中使用2019年的新特性，那么页面就不会“损坏” —— 未识别的CSS/HTML将被跳过，而其余的将被正确处理。</p>
<p>在编程语言设计中包含向前兼容性似乎是可取的，但是这样做通常是不切实际的。标记（HTML）或层叠样式表（CSS）本质上是声明性的，因此“跳过”未识别的声明要容易的多，而且对其他已识别的声明影响最小。</p>
<p>但是，如果编程语言引擎有选择的跳过它不理解的语句（甚至表达式），就会产生混乱和不确定性，因为不可能确保程序的后续部分不期望跳过的部分被处理。</p>
<p>尽管JS不是，也不可能是向前兼容的，但认识到JS的向后兼容是至关重要的，包括它对web的持久好处以及它给JS带来的限制和困难。</p>
<h3 id="Jumping-the-Gaps"><a href="#Jumping-the-Gaps" class="headerlink" title="Jumping the Gaps"></a>Jumping the Gaps</h3><p>由于JS不是向前兼容的，这意味着在你可以编写有效的JS代码和你的站点或应用程序需要支持最老的引擎之间总是存在潜在的差距。如果你在2016年的引擎中运行一个使用ES2019特性的程序。你可能看到程序崩溃。</p>
<p>如果特性是一种新的语法，程序通常会完全无法编译和运行，通常会抛出语法错误。如果特性是API（比如ES6的Object.is(…)），程序可能运行到某个点，但随后抛出运行时异常，并在遇到对未知API的引用时停止。</p>
<p>但这并不意味着JS开发人员应该始终落后于进度，只使用它们余姚支持的最老JS引擎环境的代码。</p>
<p>但是这确实意味着JS开发人员需要特别注意解决这个差距。</p>
<p>对于新的和不兼容的语法，解决方案是 transpiling。Transpiling是一个设计和社区发明的术语，用来描述使用工具将程序的全代码从一种形式转换成另一种形式（但仍然是作为文本的源代码）。通常，与语法相关的向前兼容性问题通过使用一个转换器（Babel）来解决。将新的语法转换为等效的旧语法。</p>
<p>例如，开发人员可能会编写这样的代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (something) &#123;</span><br><span class="line">    let x &#x3D; 3;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    let x &#x3D; 4;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是该应用程序的源代码树中的代码。但是，当生成文件部署到公共网站时，Babel就会将代码转换为如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x$0, x$1;</span><br><span class="line">if (something) &#123;</span><br><span class="line">    x$0 &#x3D; 3;</span><br><span class="line">    console.log(x$0);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    x$1 &#x3D; 4;</span><br><span class="line">    console.log(x$1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始代码片段依赖于let在不互相干扰的if和else子句中创建作用域的x变量。Babel能够生成一个等效的程序（只需最少的重复工作）只是选择用唯一的名称命名两个不同的变量，从而产生相同的互不干扰的结果。</p>
<blockquote>
<p>Note：<br>在ES6（ES2015）中引入了关键字let。只有当应用程序需要在支持JS的pre-ES6环境中运行时，才需要应用前面的transpiling例子。这里的实例只是为了简单说明。当ES6刚刚出现时，这种置换的需求非常普遍，但是到了2020年，需要支持pre-ES6环境的需求就少得多了。因此，用于交换的“目标”是一个滑动的窗口，只有当决定站点/应用程序停止支持某些旧的浏览器引擎时，该滑动窗口才会向上移动。</p>
</blockquote>
<p>你可能想知道：为什么要麻烦地使用工具将较新的语法版本转换为较旧的版本呢？我们不能只写这两个变量，然后跳过let关键字吗？原因是，强烈建议开发人员使用最新版本的JS，这样它们的代码就会很干净，并且能最有效的交流思想。</p>
<p>开发人员应该专注于编写干净的、新的语法形式，并让工具负责生成向前兼容的代码版本，该版本适合部署和运行在最古老的引擎环境中。</p>
<h3 id="Filling-the-Gaps"><a href="#Filling-the-Gaps" class="headerlink" title="Filling the Gaps"></a>Filling the Gaps</h3><p>如果向前兼容的问题是与新语法，缺少API方法，最常见的解决方案是提供一个定义废弃的API方法，如果在老的环境则充当它本身的定义，这种模式称为polyfill（又名“垫片”）</p>
<p>思考下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; getSomeRecords() returns us a promise for some</span><br><span class="line">&#x2F;&#x2F; data it will fetch</span><br><span class="line">var pr &#x3D; getSomeRecords();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; show the UI spinner while we get the data</span><br><span class="line">startSpinner();</span><br><span class="line"></span><br><span class="line">pr</span><br><span class="line">.then(renderRecords)   &#x2F;&#x2F; render if successful</span><br><span class="line">.catch(showError)      &#x2F;&#x2F; show an error if not</span><br><span class="line">.finally(hideSpinner)  &#x2F;&#x2F; always hide the spinner</span><br></pre></td></tr></table></figure>

<!--  -->

<p>这段代码使用了EDS2019特性，<code>Promise</code>原型上的<code>finally(..)</code>方法，如果在es2019以前的环境中执行这段代码，因为<code>finally(..)</code>方法并不存在，则会出现错误。</p>
<p>那么在es2019之前的环境中，<code>finally(..)</code>方法的polyfill后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (!Promise.prototype.finally) &#123;</span><br><span class="line">    Promise.prototype.finally &#x3D; function f(fn)&#123;</span><br><span class="line">        return this.then(</span><br><span class="line">            function t(v)&#123;</span><br><span class="line">                return Promise.resolve( fn() )</span><br><span class="line">                    .then(function t()&#123;</span><br><span class="line">                        return v;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            function c(e)&#123;</span><br><span class="line">                return Promise.resolve( fn() )</span><br><span class="line">                    .then(function t()&#123;</span><br><span class="line">                        throw e;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>警告<br>这只是对finally(..)的基本(不完全符合spec的)填充的简单说明。不要在代码中使用这个填充;在任何可能的地方，总是使用一个健壮的，官方的填充，例如在ES-Shim的填充/垫片收集。</p>
</blockquote>
<p>if语句通过防止它在任何JS引擎已经定义了该方法的环境中运行来保护填充定义。在较旧的环境中，定义了填充，但在较新的环境中，将悄悄地跳过if语句。</p>
<p>像Babel这样的置换器通常会检测哪些填充了您的代码需求，并自动为您提供它们。但有时您可能需要显式地包含/定义它们，其工作原理与我们刚才看到的代码片段类似。</p>
<p>始终使用最合适的特性来编写代码，以有效地传达其思想和意图。通常，这意味着使用最新稳定的JS版本。通过手动调整语法/API差异，避免对代码的可读性产生负面影响。这就是工具的作用!</p>
<p>置换和填充是解决使用语言中最新稳定特性的代码与站点或应用程序仍然需要支持的旧环境之间差距的两种高效技术。既然JS不会停止改进，差距就永远不会消失。这两种技术都应该成为未来每个JS项目生产链的标准部分。</p>
<h3 id="What’s-in-an-Interpretation"><a href="#What’s-in-an-Interpretation" class="headerlink" title="What’s in an Interpretation?"></a>What’s in an Interpretation?</h3><p>用JS写的代码有一个长期争论的问题:它是解释过的脚本还是编译过的程序?大多数人认为JS是一种解释(脚本)语言。但事实要复杂得多。</p>
<p>在编程语言历史的大部分时间里，“解释”语言和“脚本”语言一直被认为不如编译语言。造成这种尖刻的原因有很多，包括缺乏性能优化、不喜欢某种语言特征，比如脚本语言通常使用动态类型，而不是“更成熟”的静态类型语言。</p>
<p>被认为是“编译”的语言通常会产生一个可移植的(二进制)程序表示，这个程序稍后会被分发执行。由于我们用JS并没有真正观察到这种模型(我们分发源代码，而不是二进制形式)，许多人声称JS不属于这个类别。实际上，在过去的几十年里，程序的“可执行”形式的发布模型已经变得非常多样化，也不那么相关了;对于手头的问题，传递何种形式的程序实际上已经不那么重要了。</p>
<p>这些错误的主张和批评应该放在一边。清楚地了解JS是解释还是编译的真正原因与错误处理的本质有关。</p>
<p>从历史上看，脚本语言或解释语言通常是自上而下、逐行执行的;在开始执行之前，通常没有程序的初始化过程来处理它(参见图1)。</p>
<img src="https://github.com/YSZ0927/You-Dont-Know-JS/raw/2nd-ed/get-started/images/fig1.svg">

<p>在脚本语言或解释语言中，只有在第1行到第4行已经执行之后，程序的第5行上的错误才会被发现。值得注意的是，第5行上的错误可能是由于运行时条件造成的，比如某个变量或值不适合某个操作，或者可能是由于该行上的语句/命令格式不正确造成的。根据上下文的不同，将错误处理延迟到发生错误的行可能是可取的，也可能是不可取的。</p>
<p>将其与那些在执行之前经过处理步骤(通常称为解析)的语言进行比较，如图2所示:</p>
<img src="https://github.com/YSZ0927/You-Dont-Know-JS/raw/2nd-ed/get-started/images/fig2.svg">

<p>在这个处理模型中，在解析阶段，在任何执行开始之前，第5行上一个无效的命令(比如语法错误)将被捕获，并且程序将不会运行。为了捕获语法错误(或者“静态”错误)，通常最好在执行失败的部分之前知道它们。</p>
<p>那么“解析”语言和“编译”语言有什么共同之处呢?首先，解析所有编译语言。因此，一种经过解析的语言离被编译还有很长的路要走。在经典的编译理论中，解析后的最后一步是代码生成:生成可执行的表单。</p>
<p>一旦任何源程序被完全解析，它的后续执行通常会以某种形式包括从已解析形式的程序(通常称为抽象语法树(AST))到可执行形式的转换。</p>
<p>换句话说，经过解析的语言通常还会在执行之前执行代码生成，因此，从本质上说，它们是编译语言并不夸张。</p>
<p>JS源代码在执行前被解析。规范也有同样的要求，因为它要求在代码开始执行之前报告“早期错误”——代码中静态确定的错误，比如重复的参数名。如果没有对代码进行解析，就无法识别这些错误。</p>
<p>所以JS是一种解析语言，但它是编译的吗?</p>
<p>答案更接近“是”，而不是“否”。将解析后的JS转换为优化的(二进制)格式，然后执行该“代码”(图2);引擎在完成所有艰难的解析工作后通常不会切换回逐行执行模式(如图1所示)—大多数语言/引擎不会切换回逐行执行模式，因为这样效率非常低。</p>
<p>具体来说，这个“编译”产生一个二进制字节代码，然后将其交给“JS虚拟机”执行。有些人喜欢说这个VM“解释”字节码。但这意味着Java和其他十几个jvm驱动的语言都是解释的，而不是编译的。当然，这与Java/etc是编译语言的典型断言相矛盾。</p>
<p>有趣的是，虽然Java和JavaScript是两种非常不同的语言，但是它们之间解释/编译的问题是非常密切相关的!</p>
<p>另一个问题是，JS引擎可以对生成的代码使用多次JIT(即时)处理/优化(解析后)，这也可以根据视角合理地标记为“编译”或“解释”。这实际上是一个非常复杂的情况下，引擎盖下的JS引擎。</p>
<p>那么这些细节到底是什么呢?退后一步，考虑一个JS源程序的整个流程:</p>
<ol>
<li><p>当一个程序离开开发人员的编辑器后，它会被Babel转换，然后被Webpack打包(也许还有其他六种构建过程)，然后它会以完全不同的形式交付给一个JS引擎。</p>
</li>
<li><p>JS引擎将代码解析为AST。</p>
</li>
<li><p>然后引擎将AST转换为一种字节代码，一种二进制中间表示(IR)，然后由优化的JIT编译器进一步改进/转换。</p>
</li>
<li><p>最后，JS VM执行程序。</p>
</li>
</ol>
<p>为了使这些步骤形象化，如下图:</p>
<img src="https://github.com/YSZ0927/You-Dont-Know-JS/raw/2nd-ed/get-started/images/fig3.svg"/>

<p>JS是像图1那样逐行解释的脚本，还是像编译语言那样在执行之前先经过一对多的处理(如图2和图3)?</p>
<p>我认为在精神上，如果不是在实践中，JS是一种编译语言是很明显的。</p>
<p>同样，重要的原因是，由于JS是编译的，所以在执行代码之前，我们会被告知静态错误(比如语法错误)。与传统的“脚本化”程序相比，这是一种实质上不同的交互模型，而且可以说更有帮助!</p>
<h3 id="Web-Assembly-WASM"><a href="#Web-Assembly-WASM" class="headerlink" title="Web Assembly (WASM)"></a>Web Assembly (WASM)</h3><p>同如何更快的解析、编译和执行JS一样，促使JS性能上的进化是一个主要方面。</p>
<p>2013年,来自Mozilla Firefox的工程师们演示了一个端口的虚幻3游戏引擎从C到JS。这个代码运行在一组特殊的JS引擎中，它具备浏览器的JS引擎能力，并且满60fps性能，属于一组优化引擎，它之所以可以执行是因为JS版本的虚幻引擎的代码风格的代码支持javascript语言的一个子集,名叫“ASM.js”。</p>
<p>这个子集是有些不常见的正常编码的有效JS书面的方式,但一些重要信号输入信息引擎,允许它做优化的关键。JS的引入是为了解决JS运行时性能方面的压力。</p>
<p>但是需要注意的是，ASM.js从来没有打算成为由开发人员编写的代码，而是从另一种语言(比如C)转换而来的程序的表示，在这种语言中，这些输入“注释”是由工具自动插入的。</p>
<p>在ASM.js证明了工具创建的程序版本能够被JS引擎更高效地处理的有效性之后几年，另一组工程师(最初也是来自Mozilla)发布了Web Assembly (WASM)。</p>
<p>WASM与ASM.js的相似之处在于，它最初的目的是为非JS程序(C等)提供一条路径，以便将其转换为可以在JS引擎中运行的格式。不像ASM。js, WASM选择另外绕过一些固有的延迟js解析/编译一个程序执行之前,代表项目以一种完全不同于js。</p>
<p>WASM表示格式更接近于汇编(因此,它的名字),可以通过跳过处理JS引擎解析/编译通常JS引擎。解析/ WASM-targeted程序的编译发生提前(AOT);分布式是binary-packed程序准备JS引擎执行非常小的处理。</p>
<p>WASM最初的动机显然是潜在的性能改进。尽管这仍然是一个焦点,WASM是另外的渴望驱使带来更多的平价没有js语言网络平台。例如，如果像Go这样的语言支持线程编程，而JS(语言)不支持，WASM提供了将这样的Go程序转换成JS引擎可以理解的形式的可能性，而不需要JS语言本身的线程特性。</p>
<p>换句话说,WASM缓解压力将特性添加到JS大多/只打算使用transpiled程序从其他语言。这意味着JS功能开发可以判断(TC39)没有被利益倾斜/要求在其他语言生态系统,同时还让这些语言有一个可行的路径。</p>
<p>有趣的是，关于WASM出现的另一个观点甚至与web (W)没有直接关系，WASM正在演变为一种跨平台虚拟机(VM)，程序可以在其中一次编译并在各种不同的系统环境中运行。</p>
<p>所以,WASM不仅为网络,WASM也不是JS。具有讽刺意味的是,尽管WASM在JS引擎运行,JS语言是最不合适的语言之一WASM项目来源,因为WASM严重依赖静态类型信息。甚至TypeScript(TS)表面上,JS +静态类型不合适(目前)transpile WASM,尽管语言变体如AssemblyScript正试图桥JS / TS和WASM之间的差距。</p>
<p>这本书不是WASM,所以我不会花更多的时间讨论它,除了最后一点。有些人建议WASM指向未来,JS是切除,或最小化,网络。这些人经常对JS怀有不良的情感,要一些其他语言语言!——取代它。WASM让其他语言在JS引擎运行以来,表面上这并不是一个完全的童话。</p>
<p>但是让我明确一点:WASM将不会取代JS。WASM显著增强web(包括JS)可以完成什么。这是一件很棒的事情,完全正交是否有些人会把它作为一个逃生出口从编写JS。</p>
<h3 id="Strictly-Speaking"><a href="#Strictly-Speaking" class="headerlink" title="Strictly Speaking"></a>Strictly Speaking</h3><p>回到2009年，在发布ES5的时候,JS添加严格模式作为鼓励更好的选择机制JS程序。</p>
<p>严格模式所带来的好处远远大于成本,但旧习难改,现有(又名“遗留”)的惯性代码很难转变。如此可悲的是,十多年后,严格模式的可选性不一定意味着它仍然是默认为JS程序员。</p>
<p>为什么严格模式?严格模式不应该被认为是限制你不能做什么,而是作为一个指南,最好的方法去做事情,这样JS引擎优化和有效地运行代码的最佳机会。大多数JS代码的工作团队的开发人员,所以严格的strict-ness模式(连同工具像棉绒!)经常帮助合作代码通过避免一些问题的错误在昨日的下跌,非严格模式。</p>
<p>最严格的模式控制形式的早期错误,意思不是严格意义上的语法错误的错误但仍扔在编译时(在代码运行之前)。例如,严格模式不允许命名两个函数参数相同,和结果在早期错误。其他一些严格的模式控制只在运行时可观察到的,比如如何给<code>this</code>默认<code>undefined</code>而不是全局对象。</p>
<p>而不是战斗和争吵与严格的模式,像一个孩子只是想挑战不管他们的父母告诉他们不要做什么,最好的心态是严格模式就像一个短绒提醒你应该如何编写JS有最高的质量和最好的机会在性能。如果你发现自己感觉戴上手铐,试图在严格模式下工作,这应该是一个刺耳的红色警告标记,你需要备份和反思整个方法。</p>
<p>严格模式与一个特殊的编译指示打开每个文件(之前不允许评论/空格除外):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; only whitespace and comments are allowed</span><br><span class="line">&#x2F;&#x2F; before the use-strict pragma</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">&#x2F;&#x2F; the rest of the file runs in strict mode</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是,即使是一只流浪<code>;</code>本身出现在严格模式编译指示将呈现编译指示无用的;不抛出错误,因为它是有效的JS有一个字符串表达式在一份声明中位置,但它也不会默默地打开严格模式!</p>
</blockquote>
<p>严格模式也可以适用范围,则对其环境完全相同的规则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function someOperations() &#123;</span><br><span class="line">    &#x2F;&#x2F; whitespace and comments are fine here</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; all this code will run in strict mode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有趣的是,如果文件有严格的模式打开,函数层次严格模式语法是不允许的。所以你必须选择一个或另一个。</p>
<p>唯一有效的理由使用方法严格模式则是当你转换现有的非严格模式程序文件,需要修改一点点。否则,轮到大大更好只是严格的模式在整个文件/程序。</p>
<p>许多人想知道的时候会有JS做严格模式默认?答案是,几乎可以肯定不是。正如我们前面所讨论的向后兼容性,如果一个JS引擎更新开始假设代码严格模式即使它不是,这是可能的,这段代码将打破由于严格模式的控制。</p>
<p>然而,有几个因素,减少未来影响非严格的“obscurity”模式。</p>
<p>一方面,几乎所有transpiled代码最终在严格模式下即使原始源代码不是这样写的。大多数JS代码transpiled在生产,这意味着大多数JS已经坚持严格的模式。假设可以撤销,但你真的需要出去,这是极不可能的。</p>
<p>此外,广泛发生转向更多/大多数新JS代码使用ES6模块格式写的。ES6模块承担严格的模式,因此所有代码在这些文件是严格模式自动违约。</p>
<p>综上所述,严格模式在很大程度上是实际违约,即使技术上其实不是默认。</p>
<h3 id="Defined"><a href="#Defined" class="headerlink" title="Defined"></a>Defined</h3><p>JS是一个ECMAScript标准的实现(版本ES2019在撰写本文时),是由TC39委员会指导下,由ECMA主持。它运行在浏览器和其他JS环境如node.JS。</p>
<p>JS是一种多范型的语言,语法意义和功能允许开发人员混合和匹配(弯曲和重塑!)概念从不同的主要范式,如程序、面向对象(OO /类)和功能(FP)。</p>
<p>JS是一个编译语言,这意味着工具(包括JS引擎)过程和验证程序(报告任何错误!)之前执行。</p>
<p>现在我们的语言定义,让我们开始了解它的来龙去脉。</p>
<p>【附录B】2019年ECMAScript语言规范附录B:额外的ECMAScript特性的Web浏览器,<a href="https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers" target="_blank" rel="noopener">https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers</a></p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/06/02/YDK-JS-2nd-01/" data-id="ckdhetu1x000m1cum0f1n2xtw" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/2020/06/12/deno1-0/" class="article-nav-link">
        <strong class="article-nav-caption">Newer</strong>
        <div class="article-nav-title">
          
            deno1.0的发布声明（译文）
          
        </div>
      </a>
    
    
      <a href="/2020/06/01/micro-web/" class="article-nav-link">
        <strong class="article-nav-caption">Older</strong>
        <div class="article-nav-title">micro-web</div>
      </a>
    
  </nav>


            

                
                    
                        
                            

</article>
</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Hexo</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Hexo"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">首页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/categories">分类</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/js/ocean.js"></script>


</body>
</html>